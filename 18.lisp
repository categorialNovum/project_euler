(defun traverse ()
	(setf levels (reverse (read-file "triangle2.txt")))
	(setf intLines (convertFile levels))
	;(format t "~&-----------------------")
;	(format t "~&~s" levels)
	(format t "~&~s" intLines)
	(format t "~&-----------------------")
	(setf base (first intLines))
	(setf next (second intLines))
	(setf remaining (rest intLines))
	;(format t "~&Base ~s -> ~s" base (addList base))
	;(format t "~&Next ~s -> ~s" next (addList next))
	;(format t "~&-----------------------")
	(tr2 base remaining)
		
	)

(defun tr2 (paths remaining)
	;(format t "~& ***************************")
	(cond ((= 1 (length paths)) 
			(format t "~&FINAL Path : ~s" paths)	
			(format t "~&FINAL TOTAL : ~s" (addList (car paths))))	
		(t (tr2 (nextStep paths (first remaining)) (rest remaining))))) 

(defun nextStep (paths next)
	(setf newPaths nil)
	(loop for x from 0 to (1- (length next)) do
		(setf alist nil)
		(setf blist nil)
		(cond ((atom (nth x paths))
	;			(format t "~& atomic")
				(setf alist (list (nth x paths)))
				(setf blist (list (nth (1+ x) paths))))
			(t
				;(format t "~& NOT atomic")	
				(setf alist (nth x paths))
				(setf blist (nth (1+ x) paths))))
		(setf npath (list (nth x next)))
		;(format t "~&(%)")
		(setf a (addList alist))
		(setf b (addList blist))
	;	(format t "~&a : ~s : ~s" alist a)
	;	(format t "~&b : ~s : ~s" blist b)
	;	(format t "~&npath : ~s" npath)
		(cond ((or (> a b) (= a b))
			;	(format t "~&A > B")
				(setf npath (append npath alist)))	
			((< a b)
			;	(format t "~&B > A")
				(setf npath (append npath blist))))
		(setf newPaths (append newPaths (list npath)))
		;(format t "~&~s" npath)
		;(format t "~&~s" newPaths)
		;(format t "~&-----------------------")
		)
		;(format t "~&newPaths")
		newPaths	
	)

(defun addList (l)
	(cond ((zerop (length l)) 0)
		(t (+ (first l) (addList (rest l))))))

(defun read-file (filename)
	(setf paths nil)
	(with-open-file (file filename)
		(loop until (null (first (setf line (split-string (read-next file)))))do
			(setf paths (append paths (list line)))
		))
		paths)

(defun convertFile (f)
	(setf lines nil)
	(loop for i in f do
		(setf lines (append lines (list (intConversion i)))))
	lines)

(defun intConversion (l)
	(setf ints nil)
	(loop for i in l do
		(setf ints (append ints (list (parse-integer i)))))
	ints)
		
(defun read-next (fin)
	(read-line fin nil))


(defun split-string (str)
	(loop for i = 0 then (1+ j)
		as j = (position #\Space str :start i)
		collect (subseq str i j)
		while j))
